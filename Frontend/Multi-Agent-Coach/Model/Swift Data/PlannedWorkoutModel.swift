//
//  PlannedWorkoutModel.swift
//  Multi-Agent-Coach
//
//  Created by Ben Pearman on 2025-10-08.
//
/// The view model for a planned workout activity. A planned workout activity is one that is generated by the AI Coach and passed to the client.

import SwiftUI
import SwiftData

// MARK: - Day

@Model
final class DailyWorkout {
    //@Attribute(.unique) var id: UUID
    var tracking_id: UUID
    var date: Date
    
    @Relationship(deleteRule: .cascade) var sessions: [WorkoutSession]
    
    init(
        tracking_id: UUID = UUID(),
         date: Date = .now,
         sessions: [WorkoutSession] = []
    ) {
        self.tracking_id = tracking_id
        self.date = date
        self.sessions = sessions
    }
}

// MARK: - Polymorphic base

@Model
class WorkoutSession: Identifiable {
    //@Attribute(.unique) var id: UUID
    
    var activity: ActivityTypeEnum
    var sessionDescription: String
    
    init(
        //id: UUID = UUID(),
        activity: ActivityTypeEnum,
        sessionDescription: String = ""
    ) {
        //self.id = id
        self.activity = activity
        self.sessionDescription = sessionDescription
    }

}

// MARK: - Running
@available(iOS 26.0, *)
@Model
final class RunningWorkout: WorkoutSession {
    var distanceKm: Double
    var heartRate: Int
    var elevationGain: Int
    var paceMinPerKm: TimeInterval // Seconds per km

    init(
        sessionDescription: String = "",
        distanceKm: Double,
        heartRate: Int,
        elevationGain: Int,
        paceMinPerKm: TimeInterval
    ) {
        self.distanceKm = distanceKm
        self.heartRate = heartRate
        self.elevationGain = elevationGain
        self.paceMinPerKm = paceMinPerKm
        super.init(activity: .running, sessionDescription: sessionDescription)
    }
    
    
    func toDTO() -> RunningWorkoutDTO {
        return RunningWorkoutDTO(sessionDescription: self.sessionDescription,
                                 distanceKm: self.distanceKm,
                                 heartRate: self.heartRate,
                                 elevationGain: self.elevationGain,
                                 paceMinPerKm: self.paceMinPerKm)
    }
}


// MARK: - Climbing (+ child routes)
@available(iOS 26.0, *)
@Model
final class ClimbingWorkout: WorkoutSession {
   
    @Relationship(deleteRule: .cascade) var routes: [ClimbRoute] = []

    init(
        sessionDescription: String = "",
        routes: [ClimbRoute] = []
    ) {
        self.routes = routes
        super.init(activity: .climbing, sessionDescription: sessionDescription)
    }
    
    func toDTO() -> ClimbingWorkoutDTO {
        var routes: [ClimbRouteDTO] = []
        for climbRoute in self.routes {
            routes.append(climbRoute.toDTO())
        }
        let climbingWorkoutDTO = ClimbingWorkoutDTO(sessionDescription: self.sessionDescription, routes: routes)
        
        return climbingWorkoutDTO
    }
 
}

@available(iOS 26.0, *)
@Model
final class ClimbRoute {
//    @Attribute(.unique) var id: UUID
    var gradeValue: GradeValue
    var shortDescription: String

    init(
 //       id: UUID = UUID(),
        gradeValue: GradeValue,
        shortDescription: String = ""
    ) {
 //       self.id = id
        self.gradeValue = gradeValue
        self.shortDescription = shortDescription
    }
    
    // Create a data transfer object
    func toDTO() -> ClimbRouteDTO {
        let climbRouteDTO = ClimbRouteDTO(gradeValue: self.gradeValue, shortDescription: self.shortDescription)
        return climbRouteDTO
    }
    
    // initialize from a  data transfer object
    init(dto: ClimbRouteDTO) {
        // perform any validation or mapping
        self.gradeValue = dto.gradeValue
        self.shortDescription = dto.shortDescription
    }
    
}


// MARK: - DTOs

struct DailyWorkoutDTO: Codable {
    var tracking_id: UUID
    var date: Date
    var sessions: [AnyWorkoutSessionDTO]
}

protocol WorkoutSessionDTO: Codable {
    var sessionDescription: String { get set }
    var activity: ActivityTypeEnum { get }
}

struct RunningWorkoutDTO: WorkoutSessionDTO {
    var sessionDescription: String
    var activity: ActivityTypeEnum = ActivityTypeEnum.running
    
    var distanceKm: Double
    var heartRate: Int
    var elevationGain: Int
    var paceMinPerKm: TimeInterval
}

struct ClimbingWorkoutDTO: WorkoutSessionDTO {
    var sessionDescription: String
    var activity: ActivityTypeEnum = ActivityTypeEnum.climbing
    
    var routes: [ClimbRouteDTO] = []
}

struct ClimbRouteDTO: Codable {
    var id = UUID()
    var gradeValue: GradeValue
    var shortDescription: String
}

// A type-erased, codable wrapper for heterogeneous session DTOs
enum AnyWorkoutSessionDTO: Codable {
    case running(RunningWorkoutDTO)
    case climbing(ClimbingWorkoutDTO)
    
    var activity: ActivityTypeEnum {
        switch self {
        case .running(let dto): return dto.activity
        case .climbing(let dto): return dto.activity
        }
    }
    
    var sessionDescription: String {
        get {
            switch self {
            case .running(let dto): return dto.sessionDescription
            case .climbing(let dto): return dto.sessionDescription
            }
        }
        set {
            switch self {
            case .running(var dto):
                dto.sessionDescription = newValue
                self = .running(dto)
            case .climbing(var dto):
                dto.sessionDescription = newValue
                self = .climbing(dto)
            }
        }
    }
    
    private enum DiscriminatorCodingKeys: String, CodingKey {
        case activity
    }
    
    func encode(to encoder: any Encoder) throws {
        switch self {
        case .running(let dto):
            try dto.encode(to: encoder)
        case .climbing(let dto):
            try dto.encode(to: encoder)
        }
    }
    
    init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: DiscriminatorCodingKeys.self)
        let activity = try container.decode(ActivityTypeEnum.self, forKey: .activity)
        switch activity {
        case .running:
            self = .running(try RunningWorkoutDTO(from: decoder))
        case .climbing:
            self = .climbing(try ClimbingWorkoutDTO(from: decoder))
        }
    }
}
